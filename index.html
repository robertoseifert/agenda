<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agendador de Roberto</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 100%;
            max-width: 500px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .audio-controls {
            display: block;
            margin-bottom: 15px;
        }

        /* Estilo base para todos os botões (incluindo o recordBtn) */
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        /* Estilo específico para o botão de Gravação */
        #recordBtn {
            margin-bottom: 10px;
            font-size: 14px;
            padding: 10px;
        }

        /* Estilo para o estado de "Gravando" (Apertado) */
        #recordBtn.is-recording {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            transform: scale(0.98); 
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .recording-status {
            color: red;
            font-weight: bold;
            display: none;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .message {
            margin-top: 20px;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📅 Agenda de Roberto</h1>
        <p class="subtitle">Aperte e segure o microfone para gravar, ou digite o evento.</p>

        <form id="eventForm">
            
            <div class="audio-controls">
                <button type="button" id="recordBtn">🎤 Aperte e Segure para Gravar</button>
            </div>
            
            <p class="recording-status" id="recordingStatus">🔴 Solte para Enviar...</p>

            <div class="form-group">
                <textarea 
                    id="eventMessage" 
                    name="eventMessage" 
                    placeholder="Ex: Reunião com cliente amanhã às 14h sobre proposta de projeto"
                ></textarea>
            </div>

            <button type="submit" id="submitBtn">Enviar Somente Texto</button>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Enviando...</p>
            </div>

            <div class="message" id="message"></div>
        </form>
    </div>

    <script>
        const form = document.getElementById('eventForm');
        const submitBtn = document.getElementById('submitBtn');
        const loading = document.getElementById('loading');
        const messageDiv = document.getElementById('message');
        const recordBtn = document.getElementById('recordBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const eventMessageField = document.getElementById('eventMessage');
        
        // ** URL do seu Webhook **
        const webhookUrl = 'https://4f516537b972.ngrok-free.app/webhook/webhook'; 

        // Variáveis de gravação
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob = null; 
        let stream = null; 
        let isRecording = false;
        let recordingStartTime = 0; 
        let base64Audio = null;

        // ------------------------------------
        // FUNÇÕES DE GRAVAÇÃO (MOUSEDOWN / MOUSEUP)
        // ------------------------------------

        // MOUSE DOWN (ou Touch Start): Inicia a gravação
        recordBtn.addEventListener('mousedown', startRecordingOrTouch);
        recordBtn.addEventListener('touchstart', startRecordingOrTouch);

        // MOUSE UP (ou Touch End): Para a gravação e envia
        recordBtn.addEventListener('mouseup', stopRecordingAndSendOrTouch);
        recordBtn.addEventListener('touchend', stopRecordingAndSendOrTouch);


        async function startRecordingOrTouch(event) {
            // Ignora cliques do botão direito, etc.
            if (event.type === 'mousedown' && event.button !== 0) return; 
            // Para prevenir que o evento de toque dispare um evento de mouse
            event.preventDefault();

            // Se já estiver gravando, ignora o evento
            if (isRecording) return;

            try {
                if (!stream) {
                    // 1. Pede permissão e obtém a stream APENAS na primeira vez
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    showMessage('Microfone liberado. Aperte e segure para gravar e solte para enviar.', 'success');
                }
                
                // Inicia a gravação
                audioChunks = [];
                audioBlob = null;
                base64Audio = null; 
                
                mediaRecorder = new MediaRecorder(stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now(); // Marca o tempo de início

                // Atualiza a interface
                recordBtn.textContent = '🔴 Solte para Enviar';
                recordBtn.classList.add('is-recording'); 
                eventMessageField.disabled = true;
                recordingStatus.style.display = 'block';
                messageDiv.className = 'message'; // Limpa mensagens anteriores

            } catch (err) {
                console.error('Erro ao acessar o microfone:', err);
                showMessage('Erro: Microfone bloqueado. Habilite a permissão no navegador.', 'error');
                isRecording = false; // Garante que o estado seja falso em caso de erro
            }
        }


        async function stopRecordingAndSendOrTouch() {
            if (!isRecording || !mediaRecorder || mediaRecorder.state !== 'recording') return;

            mediaRecorder.stop();
            isRecording = false;
            
            const recordingDuration = Date.now() - recordingStartTime;
            const MIN_DURATION_MS = 500; // Duração mínima para considerar o áudio válido

            // Aguarda o evento onstop do MediaRecorder para ter o audioBlob completo
            mediaRecorder.onstop = async () => {
                
                const mimeType = mediaRecorder.mimeType.startsWith('audio/') ? mediaRecorder.mimeType : 'audio/webm';
                audioBlob = new Blob(audioChunks, { type: mimeType });

                // Atualiza a interface (sem o envio ainda)
                recordBtn.textContent = '🎤 Aperte e Segure para Gravar';
                recordBtn.classList.remove('is-recording');
                eventMessageField.disabled = false;
                recordingStatus.style.display = 'none';

                if (recordingDuration < MIN_DURATION_MS) {
                    showMessage('Gravação muito curta. Aperte e segure por mais tempo.', 'error');
                    audioBlob = null;
                    return;
                }
                
                // 1. Converte o Blob para Base64
                base64Audio = await convertBlobToBase64(audioBlob);
                
                // 2. DISPARA O ENVIO JSON (com Base64)
                await sendJsonData(eventMessageField.value.trim(), base64Audio, mimeType);

                audioBlob = null; 
                base64Audio = null;
            };
        }
        
        // FUNÇÃO AUXILIAR: Converte Blob para Base64
        function convertBlobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = () => {
                    // O reader.result já contém o prefixo (data:audio/webm;base64,...), 
                    // o que é útil para ser reproduzido diretamente se necessário.
                    resolve(reader.result);
                };
                reader.onerror = reject;
            });
        }


        // ------------------------------------
        // FUNÇÃO DE ENVIO JSON
        // ------------------------------------
        
        // Envio com o botão de submit (apenas texto)
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            
            if (isRecording) {
                showMessage('Solte o botão para enviar o áudio.', 'error');
            } else {
                 // Envia a mensagem de texto normal, Base64 será nulo.
                 sendJsonData(eventMessageField.value.trim(), null, null); 
            }
        });

        // Função principal de envio de dados (Texto + Base64)
        async function sendJsonData(eventMessage, audioData, mimeType) {
            
            if (!eventMessage && !audioData) {
                showMessage('Por favor, descreva o evento ou grave um áudio.', 'error');
                return;
            }
            
            // Cria o payload JSON
            const payload = {
                message: eventMessage,
                // Adiciona Base64 e MIME Type APENAS se houver áudio
                ...(audioData && { 
                    audio_base64: audioData,
                    audio_mime_type: mimeType
                })
            };

            submitBtn.disabled = true;
            recordBtn.disabled = true; 
            loading.classList.add('active');
            messageDiv.className = 'message';

            try {
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        // Envia como JSON
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload) 
                });

                if (response.ok) {
                    showMessage(`✓ Evento enviado com sucesso! ${audioData ? '(Com Áudio Base64)' : '(Somente Texto)'}`, 'success');
                    eventMessageField.value = '';
                } else {
                    const errorText = await response.text();
                    showMessage(`Erro: ${response.status} ${response.statusText}. Detalhe: ${errorText.substring(0, 100)}...`, 'error');
                }
            } catch (error) {
                console.error('Erro:', error);
                showMessage(`Erro ao enviar: ${error.message}`, 'error');
            } finally {
                submitBtn.disabled = false;
                recordBtn.disabled = false;
                loading.classList.remove('active');
            }
        }

        // ------------------------------------
        // FUNÇÕES DE UI
        // ------------------------------------
        function showMessage(text, type) {
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;
            
            if (type === 'success') {
                setTimeout(() => {
                    messageDiv.className = 'message';
                }, 5000);
            }
        }
    </script>
</body>
</html>
